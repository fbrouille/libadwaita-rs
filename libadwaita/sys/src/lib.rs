// This file was generated by gir (https://github.com/gtk-rs/gir @ 0ae3977)
// from gir-files (https://github.com/gtk-rs/gir-files @ a8cfb0c)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal
)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]

use gdk_pixbuf_sys as gdk_pixbuf;
use gdk_sys as gdk;
use gio_sys as gio;
use glib_sys as glib;
use gobject_sys as gobject;
use gtk_sys as gtk;
use pango_sys as pango;

#[allow(unused_imports)]
use libc::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
    intptr_t, size_t, ssize_t, time_t, uintptr_t, FILE,
};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type HdyCenteringPolicy = c_int;
pub const HDY_CENTERING_POLICY_LOOSE: HdyCenteringPolicy = 0;
pub const HDY_CENTERING_POLICY_STRICT: HdyCenteringPolicy = 1;

pub type HdyFlapFoldPolicy = c_int;
pub const HDY_FLAP_FOLD_POLICY_NEVER: HdyFlapFoldPolicy = 0;
pub const HDY_FLAP_FOLD_POLICY_ALWAYS: HdyFlapFoldPolicy = 1;
pub const HDY_FLAP_FOLD_POLICY_AUTO: HdyFlapFoldPolicy = 2;

pub type HdyFlapTransitionType = c_int;
pub const HDY_FLAP_TRANSITION_TYPE_OVER: HdyFlapTransitionType = 0;
pub const HDY_FLAP_TRANSITION_TYPE_UNDER: HdyFlapTransitionType = 1;
pub const HDY_FLAP_TRANSITION_TYPE_SLIDE: HdyFlapTransitionType = 2;

pub type HdyHeaderGroupChildType = c_int;
pub const HDY_HEADER_GROUP_CHILD_TYPE_HEADER_BAR: HdyHeaderGroupChildType = 0;
pub const HDY_HEADER_GROUP_CHILD_TYPE_GTK_HEADER_BAR: HdyHeaderGroupChildType = 1;
pub const HDY_HEADER_GROUP_CHILD_TYPE_HEADER_GROUP: HdyHeaderGroupChildType = 2;

pub type HdyLeafletTransitionType = c_int;
pub const HDY_LEAFLET_TRANSITION_TYPE_OVER: HdyLeafletTransitionType = 0;
pub const HDY_LEAFLET_TRANSITION_TYPE_UNDER: HdyLeafletTransitionType = 1;
pub const HDY_LEAFLET_TRANSITION_TYPE_SLIDE: HdyLeafletTransitionType = 2;

pub type HdyNavigationDirection = c_int;
pub const HDY_NAVIGATION_DIRECTION_BACK: HdyNavigationDirection = 0;
pub const HDY_NAVIGATION_DIRECTION_FORWARD: HdyNavigationDirection = 1;

pub type HdySqueezerTransitionType = c_int;
pub const HDY_SQUEEZER_TRANSITION_TYPE_NONE: HdySqueezerTransitionType = 0;
pub const HDY_SQUEEZER_TRANSITION_TYPE_CROSSFADE: HdySqueezerTransitionType = 1;

pub type HdyViewSwitcherPolicy = c_int;
pub const HDY_VIEW_SWITCHER_POLICY_AUTO: HdyViewSwitcherPolicy = 0;
pub const HDY_VIEW_SWITCHER_POLICY_NARROW: HdyViewSwitcherPolicy = 1;
pub const HDY_VIEW_SWITCHER_POLICY_WIDE: HdyViewSwitcherPolicy = 2;

// Callbacks
pub type HdyAvatarImageLoadFunc =
    Option<unsafe extern "C" fn(c_int, gpointer) -> *mut gdk_pixbuf::GdkPixbuf>;
pub type HdyComboRowGetEnumValueNameFunc =
    Option<unsafe extern "C" fn(*mut HdyEnumValueObject, gpointer) -> *mut c_char>;
pub type HdyComboRowGetNameFunc =
    Option<unsafe extern "C" fn(*mut gobject::GObject, gpointer) -> *mut c_char>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyActionRowClass {
    pub parent_class: gtk::GtkListBoxRowClass,
    pub activate: Option<unsafe extern "C" fn(*mut HdyActionRow)>,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyActionRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyActionRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .field("activate", &self.activate)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyApplicationWindowClass {
    pub parent_class: gtk::GtkApplicationWindowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyApplicationWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyApplicationWindowClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyAvatarClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyAvatarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyAvatarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyCarouselClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyCarouselClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyCarouselClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyCarouselIndicatorDotsClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyCarouselIndicatorDotsClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorDotsClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyCarouselIndicatorLinesClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyCarouselIndicatorLinesClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorLinesClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyClampClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyClampClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClampClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyClampLayoutClass {
    pub parent_class: gtk::GtkLayoutManagerClass,
}

impl ::std::fmt::Debug for HdyClampLayoutClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClampLayoutClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyClampScrollableClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyClampScrollableClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClampScrollableClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyComboRowClass {
    pub parent_class: HdyActionRowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyComboRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyComboRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyEnumListModelClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyEnumListModelClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyEnumListModelClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyEnumValueObjectClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyEnumValueObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyEnumValueObjectClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyExpanderRowClass {
    pub parent_class: HdyPreferencesRowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyExpanderRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyExpanderRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyFlapClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyFlapClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyFlapClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyHeaderBarClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyHeaderBarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderBarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyHeaderGroupChildClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyHeaderGroupChildClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyHeaderGroupChildClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyHeaderGroupClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyHeaderGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderGroupClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyKeypadClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyKeypadClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyKeypadClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyLeafletClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyLeafletClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyLeafletClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyLeafletPageClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyLeafletPageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyLeafletPageClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesGroupClass {
    pub parent_class: gtk::GtkWidgetClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyPreferencesGroupClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesPageClass {
    pub parent_class: gtk::GtkWidgetClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesPageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesPageClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesRowClass {
    pub parent_class: gtk::GtkListBoxRowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesRowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesRowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesWindowClass {
    pub parent_class: HdyWindowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyPreferencesWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyPreferencesWindowClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySqueezerClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdySqueezerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySqueezerClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySqueezerPageClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdySqueezerPageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySqueezerPageClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyStatusPageClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyStatusPageClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyStatusPageClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySwipeGroupClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdySwipeGroupClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeGroupClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySwipeTrackerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdySwipeTrackerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeTrackerClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdySwipeableInterface {
    pub parent: gobject::GTypeInterface,
    pub switch_child: Option<unsafe extern "C" fn(*mut HdySwipeable, c_uint, i64)>,
    pub get_swipe_tracker: Option<unsafe extern "C" fn(*mut HdySwipeable) -> *mut HdySwipeTracker>,
    pub get_distance: Option<unsafe extern "C" fn(*mut HdySwipeable) -> c_double>,
    pub get_snap_points:
        Option<unsafe extern "C" fn(*mut HdySwipeable, *mut c_int) -> *mut c_double>,
    pub get_progress: Option<unsafe extern "C" fn(*mut HdySwipeable) -> c_double>,
    pub get_cancel_progress: Option<unsafe extern "C" fn(*mut HdySwipeable) -> c_double>,
    pub get_swipe_area: Option<
        unsafe extern "C" fn(
            *mut HdySwipeable,
            HdyNavigationDirection,
            gboolean,
            *mut gdk::GdkRectangle,
        ),
    >,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdySwipeableInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeableInterface @ {:?}", self as *const _))
            .field("parent", &self.parent)
            .field("switch_child", &self.switch_child)
            .field("get_swipe_tracker", &self.get_swipe_tracker)
            .field("get_distance", &self.get_distance)
            .field("get_snap_points", &self.get_snap_points)
            .field("get_progress", &self.get_progress)
            .field("get_cancel_progress", &self.get_cancel_progress)
            .field("get_swipe_area", &self.get_swipe_area)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyValueObjectClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for HdyValueObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyValueObjectClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyViewSwitcherBarClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyViewSwitcherBarClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherBarClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyViewSwitcherClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyViewSwitcherClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyViewSwitcherTitleClass {
    pub parent_class: gtk::GtkWidgetClass,
}

impl ::std::fmt::Debug for HdyViewSwitcherTitleClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyViewSwitcherTitleClass @ {:?}",
            self as *const _
        ))
        .field("parent_class", &self.parent_class)
        .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyWindowClass {
    pub parent_class: gtk::GtkWindowClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for HdyWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyWindowClass @ {:?}", self as *const _))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyActionRow {
    pub parent_instance: HdyPreferencesRow,
}

impl ::std::fmt::Debug for HdyActionRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyActionRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyApplicationWindow {
    pub parent_instance: gtk::GtkApplicationWindow,
}

impl ::std::fmt::Debug for HdyApplicationWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyApplicationWindow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdyAvatar(c_void);

impl ::std::fmt::Debug for HdyAvatar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyAvatar @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyCarousel(c_void);

impl ::std::fmt::Debug for HdyCarousel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyCarousel @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyCarouselIndicatorDots(c_void);

impl ::std::fmt::Debug for HdyCarouselIndicatorDots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorDots @ {:?}",
            self as *const _
        ))
        .finish()
    }
}

#[repr(C)]
pub struct HdyCarouselIndicatorLines(c_void);

impl ::std::fmt::Debug for HdyCarouselIndicatorLines {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!(
            "HdyCarouselIndicatorLines @ {:?}",
            self as *const _
        ))
        .finish()
    }
}

#[repr(C)]
pub struct HdyClamp(c_void);

impl ::std::fmt::Debug for HdyClamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClamp @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyClampLayout(c_void);

impl ::std::fmt::Debug for HdyClampLayout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClampLayout @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyClampScrollable(c_void);

impl ::std::fmt::Debug for HdyClampScrollable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyClampScrollable @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyComboRow {
    pub parent_instance: HdyActionRow,
}

impl ::std::fmt::Debug for HdyComboRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyComboRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdyEnumListModel(c_void);

impl ::std::fmt::Debug for HdyEnumListModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyEnumListModel @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyEnumValueObject(c_void);

impl ::std::fmt::Debug for HdyEnumValueObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyEnumValueObject @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyExpanderRow {
    pub parent_instance: HdyPreferencesRow,
}

impl ::std::fmt::Debug for HdyExpanderRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyExpanderRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdyFlap(c_void);

impl ::std::fmt::Debug for HdyFlap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyFlap @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyHeaderBar(c_void);

impl ::std::fmt::Debug for HdyHeaderBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderBar @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyHeaderGroup(c_void);

impl ::std::fmt::Debug for HdyHeaderGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderGroup @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyHeaderGroupChild(c_void);

impl ::std::fmt::Debug for HdyHeaderGroupChild {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyHeaderGroupChild @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyKeypad(c_void);

impl ::std::fmt::Debug for HdyKeypad {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyKeypad @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyLeaflet(c_void);

impl ::std::fmt::Debug for HdyLeaflet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyLeaflet @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyLeafletPage(c_void);

impl ::std::fmt::Debug for HdyLeafletPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyLeafletPage @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesGroup {
    pub parent_instance: gtk::GtkWidget,
}

impl ::std::fmt::Debug for HdyPreferencesGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesGroup @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesPage {
    pub parent_instance: gtk::GtkWidget,
}

impl ::std::fmt::Debug for HdyPreferencesPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesPage @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesRow {
    pub parent_instance: gtk::GtkListBoxRow,
}

impl ::std::fmt::Debug for HdyPreferencesRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesRow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyPreferencesWindow {
    pub parent_instance: HdyWindow,
}

impl ::std::fmt::Debug for HdyPreferencesWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyPreferencesWindow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

#[repr(C)]
pub struct HdySqueezer(c_void);

impl ::std::fmt::Debug for HdySqueezer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySqueezer @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdySqueezerPage(c_void);

impl ::std::fmt::Debug for HdySqueezerPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySqueezerPage @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyStatusPage(c_void);

impl ::std::fmt::Debug for HdyStatusPage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyStatusPage @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdySwipeGroup(c_void);

impl ::std::fmt::Debug for HdySwipeGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeGroup @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdySwipeTracker(c_void);

impl ::std::fmt::Debug for HdySwipeTracker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdySwipeTracker @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyValueObject(c_void);

impl ::std::fmt::Debug for HdyValueObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyValueObject @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyViewSwitcher(c_void);

impl ::std::fmt::Debug for HdyViewSwitcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcher @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyViewSwitcherBar(c_void);

impl ::std::fmt::Debug for HdyViewSwitcherBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherBar @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
pub struct HdyViewSwitcherTitle(c_void);

impl ::std::fmt::Debug for HdyViewSwitcherTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyViewSwitcherTitle @ {:?}", self as *const _))
            .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct HdyWindow {
    pub parent_instance: gtk::GtkWindow,
}

impl ::std::fmt::Debug for HdyWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("HdyWindow @ {:?}", self as *const _))
            .field("parent_instance", &self.parent_instance)
            .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct HdySwipeable(c_void);

impl ::std::fmt::Debug for HdySwipeable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "HdySwipeable @ {:?}", self as *const _)
    }
}

#[link(name = "handy-4")]
extern "C" {

    //=========================================================================
    // HdyCenteringPolicy
    //=========================================================================
    pub fn hdy_centering_policy_get_type() -> GType;

    //=========================================================================
    // HdyFlapFoldPolicy
    //=========================================================================
    pub fn hdy_flap_fold_policy_get_type() -> GType;

    //=========================================================================
    // HdyFlapTransitionType
    //=========================================================================
    pub fn hdy_flap_transition_type_get_type() -> GType;

    //=========================================================================
    // HdyHeaderGroupChildType
    //=========================================================================
    pub fn hdy_header_group_child_type_get_type() -> GType;

    //=========================================================================
    // HdyLeafletTransitionType
    //=========================================================================
    pub fn hdy_leaflet_transition_type_get_type() -> GType;

    //=========================================================================
    // HdyNavigationDirection
    //=========================================================================
    pub fn hdy_navigation_direction_get_type() -> GType;

    //=========================================================================
    // HdySqueezerTransitionType
    //=========================================================================
    pub fn hdy_squeezer_transition_type_get_type() -> GType;

    //=========================================================================
    // HdyViewSwitcherPolicy
    //=========================================================================
    pub fn hdy_view_switcher_policy_get_type() -> GType;

    //=========================================================================
    // HdyActionRow
    //=========================================================================
    pub fn hdy_action_row_get_type() -> GType;
    pub fn hdy_action_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_action_row_activate(self_: *mut HdyActionRow);
    pub fn hdy_action_row_add_prefix(self_: *mut HdyActionRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_action_row_add_suffix(self_: *mut HdyActionRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_action_row_get_activatable_widget(self_: *mut HdyActionRow) -> *mut gtk::GtkWidget;
    pub fn hdy_action_row_get_icon_name(self_: *mut HdyActionRow) -> *const c_char;
    pub fn hdy_action_row_get_subtitle(self_: *mut HdyActionRow) -> *const c_char;
    pub fn hdy_action_row_get_subtitle_lines(self_: *mut HdyActionRow) -> c_int;
    pub fn hdy_action_row_get_title_lines(self_: *mut HdyActionRow) -> c_int;
    pub fn hdy_action_row_get_use_underline(self_: *mut HdyActionRow) -> gboolean;
    pub fn hdy_action_row_remove(self_: *mut HdyActionRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_action_row_set_activatable_widget(
        self_: *mut HdyActionRow,
        widget: *mut gtk::GtkWidget,
    );
    pub fn hdy_action_row_set_icon_name(self_: *mut HdyActionRow, icon_name: *const c_char);
    pub fn hdy_action_row_set_subtitle(self_: *mut HdyActionRow, subtitle: *const c_char);
    pub fn hdy_action_row_set_subtitle_lines(self_: *mut HdyActionRow, subtitle_lines: c_int);
    pub fn hdy_action_row_set_title_lines(self_: *mut HdyActionRow, title_lines: c_int);
    pub fn hdy_action_row_set_use_underline(self_: *mut HdyActionRow, use_underline: gboolean);

    //=========================================================================
    // HdyApplicationWindow
    //=========================================================================
    pub fn hdy_application_window_get_type() -> GType;
    pub fn hdy_application_window_new(app: *mut gtk::GtkApplication) -> *mut gtk::GtkWidget;
    pub fn hdy_application_window_get_child(
        self_: *mut HdyApplicationWindow,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_application_window_set_child(
        self_: *mut HdyApplicationWindow,
        child: *mut gtk::GtkWidget,
    );

    //=========================================================================
    // HdyAvatar
    //=========================================================================
    pub fn hdy_avatar_get_type() -> GType;
    pub fn hdy_avatar_new(
        size: c_int,
        text: *const c_char,
        show_initials: gboolean,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_avatar_draw_to_pixbuf(
        self_: *mut HdyAvatar,
        size: c_int,
        scale_factor: c_int,
    ) -> *mut gdk_pixbuf::GdkPixbuf;
    pub fn hdy_avatar_get_icon_name(self_: *mut HdyAvatar) -> *const c_char;
    pub fn hdy_avatar_get_show_initials(self_: *mut HdyAvatar) -> gboolean;
    pub fn hdy_avatar_get_size(self_: *mut HdyAvatar) -> c_int;
    pub fn hdy_avatar_get_text(self_: *mut HdyAvatar) -> *const c_char;
    pub fn hdy_avatar_set_icon_name(self_: *mut HdyAvatar, icon_name: *const c_char);
    pub fn hdy_avatar_set_image_load_func(
        self_: *mut HdyAvatar,
        load_image: HdyAvatarImageLoadFunc,
        user_data: gpointer,
        destroy: glib::GDestroyNotify,
    );
    pub fn hdy_avatar_set_show_initials(self_: *mut HdyAvatar, show_initials: gboolean);
    pub fn hdy_avatar_set_size(self_: *mut HdyAvatar, size: c_int);
    pub fn hdy_avatar_set_text(self_: *mut HdyAvatar, text: *const c_char);

    //=========================================================================
    // HdyCarousel
    //=========================================================================
    pub fn hdy_carousel_get_type() -> GType;
    pub fn hdy_carousel_new() -> *mut gtk::GtkWidget;
    pub fn hdy_carousel_append(self_: *mut HdyCarousel, child: *mut gtk::GtkWidget);
    pub fn hdy_carousel_get_allow_mouse_drag(self_: *mut HdyCarousel) -> gboolean;
    pub fn hdy_carousel_get_animation_duration(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_get_interactive(self_: *mut HdyCarousel) -> gboolean;
    pub fn hdy_carousel_get_n_pages(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_get_nth_page(self_: *mut HdyCarousel, n: c_uint) -> *mut gtk::GtkWidget;
    pub fn hdy_carousel_get_position(self_: *mut HdyCarousel) -> c_double;
    pub fn hdy_carousel_get_reveal_duration(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_get_spacing(self_: *mut HdyCarousel) -> c_uint;
    pub fn hdy_carousel_insert(
        self_: *mut HdyCarousel,
        child: *mut gtk::GtkWidget,
        position: c_int,
    );
    pub fn hdy_carousel_prepend(self_: *mut HdyCarousel, child: *mut gtk::GtkWidget);
    pub fn hdy_carousel_remove(self_: *mut HdyCarousel, child: *mut gtk::GtkWidget);
    pub fn hdy_carousel_reorder(
        self_: *mut HdyCarousel,
        child: *mut gtk::GtkWidget,
        position: c_int,
    );
    pub fn hdy_carousel_scroll_to(self_: *mut HdyCarousel, widget: *mut gtk::GtkWidget);
    pub fn hdy_carousel_scroll_to_full(
        self_: *mut HdyCarousel,
        widget: *mut gtk::GtkWidget,
        duration: i64,
    );
    pub fn hdy_carousel_set_allow_mouse_drag(self_: *mut HdyCarousel, allow_mouse_drag: gboolean);
    pub fn hdy_carousel_set_animation_duration(self_: *mut HdyCarousel, duration: c_uint);
    pub fn hdy_carousel_set_interactive(self_: *mut HdyCarousel, interactive: gboolean);
    pub fn hdy_carousel_set_reveal_duration(self_: *mut HdyCarousel, reveal_duration: c_uint);
    pub fn hdy_carousel_set_spacing(self_: *mut HdyCarousel, spacing: c_uint);

    //=========================================================================
    // HdyCarouselIndicatorDots
    //=========================================================================
    pub fn hdy_carousel_indicator_dots_get_type() -> GType;
    pub fn hdy_carousel_indicator_dots_new() -> *mut gtk::GtkWidget;
    pub fn hdy_carousel_indicator_dots_get_carousel(
        self_: *mut HdyCarouselIndicatorDots,
    ) -> *mut HdyCarousel;
    pub fn hdy_carousel_indicator_dots_set_carousel(
        self_: *mut HdyCarouselIndicatorDots,
        carousel: *mut HdyCarousel,
    );

    //=========================================================================
    // HdyCarouselIndicatorLines
    //=========================================================================
    pub fn hdy_carousel_indicator_lines_get_type() -> GType;
    pub fn hdy_carousel_indicator_lines_new() -> *mut gtk::GtkWidget;
    pub fn hdy_carousel_indicator_lines_get_carousel(
        self_: *mut HdyCarouselIndicatorLines,
    ) -> *mut HdyCarousel;
    pub fn hdy_carousel_indicator_lines_set_carousel(
        self_: *mut HdyCarouselIndicatorLines,
        carousel: *mut HdyCarousel,
    );

    //=========================================================================
    // HdyClamp
    //=========================================================================
    pub fn hdy_clamp_get_type() -> GType;
    pub fn hdy_clamp_new() -> *mut gtk::GtkWidget;
    pub fn hdy_clamp_get_child(self_: *mut HdyClamp) -> *mut gtk::GtkWidget;
    pub fn hdy_clamp_get_maximum_size(self_: *mut HdyClamp) -> c_int;
    pub fn hdy_clamp_get_tightening_threshold(self_: *mut HdyClamp) -> c_int;
    pub fn hdy_clamp_set_child(self_: *mut HdyClamp, child: *mut gtk::GtkWidget);
    pub fn hdy_clamp_set_maximum_size(self_: *mut HdyClamp, maximum_size: c_int);
    pub fn hdy_clamp_set_tightening_threshold(self_: *mut HdyClamp, tightening_threshold: c_int);

    //=========================================================================
    // HdyClampLayout
    //=========================================================================
    pub fn hdy_clamp_layout_get_type() -> GType;
    pub fn hdy_clamp_layout_new() -> *mut gtk::GtkLayoutManager;
    pub fn hdy_clamp_layout_get_maximum_size(self_: *mut HdyClampLayout) -> c_int;
    pub fn hdy_clamp_layout_get_tightening_threshold(self_: *mut HdyClampLayout) -> c_int;
    pub fn hdy_clamp_layout_set_maximum_size(self_: *mut HdyClampLayout, maximum_size: c_int);
    pub fn hdy_clamp_layout_set_tightening_threshold(
        self_: *mut HdyClampLayout,
        tightening_threshold: c_int,
    );

    //=========================================================================
    // HdyClampScrollable
    //=========================================================================
    pub fn hdy_clamp_scrollable_get_type() -> GType;
    pub fn hdy_clamp_scrollable_new() -> *mut gtk::GtkWidget;
    pub fn hdy_clamp_scrollable_get_child(self_: *mut HdyClampScrollable) -> *mut gtk::GtkWidget;
    pub fn hdy_clamp_scrollable_get_maximum_size(self_: *mut HdyClampScrollable) -> c_int;
    pub fn hdy_clamp_scrollable_get_tightening_threshold(self_: *mut HdyClampScrollable) -> c_int;
    pub fn hdy_clamp_scrollable_set_child(
        self_: *mut HdyClampScrollable,
        child: *mut gtk::GtkWidget,
    );
    pub fn hdy_clamp_scrollable_set_maximum_size(
        self_: *mut HdyClampScrollable,
        maximum_size: c_int,
    );
    pub fn hdy_clamp_scrollable_set_tightening_threshold(
        self_: *mut HdyClampScrollable,
        tightening_threshold: c_int,
    );

    //=========================================================================
    // HdyComboRow
    //=========================================================================
    pub fn hdy_combo_row_get_type() -> GType;
    pub fn hdy_combo_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_combo_row_get_expression(self_: *mut HdyComboRow) -> *mut gtk::GtkExpression;
    pub fn hdy_combo_row_get_factory(self_: *mut HdyComboRow) -> *mut gtk::GtkListItemFactory;
    pub fn hdy_combo_row_get_list_factory(self_: *mut HdyComboRow) -> *mut gtk::GtkListItemFactory;
    pub fn hdy_combo_row_get_model(self_: *mut HdyComboRow) -> *mut gio::GListModel;
    pub fn hdy_combo_row_get_selected(self_: *mut HdyComboRow) -> c_uint;
    pub fn hdy_combo_row_get_selected_item(self_: *mut HdyComboRow) -> *mut gobject::GObject;
    pub fn hdy_combo_row_get_use_subtitle(self_: *mut HdyComboRow) -> gboolean;
    pub fn hdy_combo_row_set_expression(
        self_: *mut HdyComboRow,
        expression: *mut gtk::GtkExpression,
    );
    pub fn hdy_combo_row_set_factory(
        self_: *mut HdyComboRow,
        factory: *mut gtk::GtkListItemFactory,
    );
    pub fn hdy_combo_row_set_list_factory(
        self_: *mut HdyComboRow,
        factory: *mut gtk::GtkListItemFactory,
    );
    pub fn hdy_combo_row_set_model(self_: *mut HdyComboRow, model: *mut gio::GListModel);
    pub fn hdy_combo_row_set_selected(self_: *mut HdyComboRow, position: c_uint);
    pub fn hdy_combo_row_set_use_subtitle(self_: *mut HdyComboRow, use_subtitle: gboolean);

    //=========================================================================
    // HdyEnumListModel
    //=========================================================================
    pub fn hdy_enum_list_model_get_type() -> GType;
    pub fn hdy_enum_list_model_new(enum_type: GType) -> *mut HdyEnumListModel;
    pub fn hdy_enum_list_model_find_position(self_: *mut HdyEnumListModel, value: c_int) -> c_uint;
    pub fn hdy_enum_list_model_get_enum_type(self_: *mut HdyEnumListModel) -> GType;

    //=========================================================================
    // HdyEnumValueObject
    //=========================================================================
    pub fn hdy_enum_value_object_get_type() -> GType;
    pub fn hdy_enum_value_object_get_name(self_: *mut HdyEnumValueObject) -> *const c_char;
    pub fn hdy_enum_value_object_get_nick(self_: *mut HdyEnumValueObject) -> *const c_char;
    pub fn hdy_enum_value_object_get_value(self_: *mut HdyEnumValueObject) -> c_int;

    //=========================================================================
    // HdyExpanderRow
    //=========================================================================
    pub fn hdy_expander_row_get_type() -> GType;
    pub fn hdy_expander_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_expander_row_add(self_: *mut HdyExpanderRow, child: *mut gtk::GtkWidget);
    pub fn hdy_expander_row_add_action(self_: *mut HdyExpanderRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_expander_row_add_prefix(self_: *mut HdyExpanderRow, widget: *mut gtk::GtkWidget);
    pub fn hdy_expander_row_get_enable_expansion(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_get_expanded(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_get_icon_name(self_: *mut HdyExpanderRow) -> *const c_char;
    pub fn hdy_expander_row_get_show_enable_switch(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_get_subtitle(self_: *mut HdyExpanderRow) -> *const c_char;
    pub fn hdy_expander_row_get_use_underline(self_: *mut HdyExpanderRow) -> gboolean;
    pub fn hdy_expander_row_remove(self_: *mut HdyExpanderRow, child: *mut gtk::GtkWidget);
    pub fn hdy_expander_row_set_enable_expansion(
        self_: *mut HdyExpanderRow,
        enable_expansion: gboolean,
    );
    pub fn hdy_expander_row_set_expanded(self_: *mut HdyExpanderRow, expanded: gboolean);
    pub fn hdy_expander_row_set_icon_name(self_: *mut HdyExpanderRow, icon_name: *const c_char);
    pub fn hdy_expander_row_set_show_enable_switch(
        self_: *mut HdyExpanderRow,
        show_enable_switch: gboolean,
    );
    pub fn hdy_expander_row_set_subtitle(self_: *mut HdyExpanderRow, subtitle: *const c_char);
    pub fn hdy_expander_row_set_use_underline(self_: *mut HdyExpanderRow, use_underline: gboolean);

    //=========================================================================
    // HdyFlap
    //=========================================================================
    pub fn hdy_flap_get_type() -> GType;
    pub fn hdy_flap_new() -> *mut gtk::GtkWidget;
    pub fn hdy_flap_get_content(self_: *mut HdyFlap) -> *mut gtk::GtkWidget;
    pub fn hdy_flap_get_flap(self_: *mut HdyFlap) -> *mut gtk::GtkWidget;
    pub fn hdy_flap_get_flap_position(self_: *mut HdyFlap) -> gtk::GtkPackType;
    pub fn hdy_flap_get_fold_duration(self_: *mut HdyFlap) -> c_uint;
    pub fn hdy_flap_get_fold_policy(self_: *mut HdyFlap) -> HdyFlapFoldPolicy;
    pub fn hdy_flap_get_folded(self_: *mut HdyFlap) -> gboolean;
    pub fn hdy_flap_get_locked(self_: *mut HdyFlap) -> gboolean;
    pub fn hdy_flap_get_modal(self_: *mut HdyFlap) -> gboolean;
    pub fn hdy_flap_get_reveal_duration(self_: *mut HdyFlap) -> c_uint;
    pub fn hdy_flap_get_reveal_flap(self_: *mut HdyFlap) -> gboolean;
    pub fn hdy_flap_get_reveal_progress(self_: *mut HdyFlap) -> c_double;
    pub fn hdy_flap_get_separator(self_: *mut HdyFlap) -> *mut gtk::GtkWidget;
    pub fn hdy_flap_get_swipe_to_close(self_: *mut HdyFlap) -> gboolean;
    pub fn hdy_flap_get_swipe_to_open(self_: *mut HdyFlap) -> gboolean;
    pub fn hdy_flap_get_transition_type(self_: *mut HdyFlap) -> HdyFlapTransitionType;
    pub fn hdy_flap_set_content(self_: *mut HdyFlap, content: *mut gtk::GtkWidget);
    pub fn hdy_flap_set_flap(self_: *mut HdyFlap, flap: *mut gtk::GtkWidget);
    pub fn hdy_flap_set_flap_position(self_: *mut HdyFlap, position: gtk::GtkPackType);
    pub fn hdy_flap_set_fold_duration(self_: *mut HdyFlap, duration: c_uint);
    pub fn hdy_flap_set_fold_policy(self_: *mut HdyFlap, policy: HdyFlapFoldPolicy);
    pub fn hdy_flap_set_locked(self_: *mut HdyFlap, locked: gboolean);
    pub fn hdy_flap_set_modal(self_: *mut HdyFlap, modal: gboolean);
    pub fn hdy_flap_set_reveal_duration(self_: *mut HdyFlap, duration: c_uint);
    pub fn hdy_flap_set_reveal_flap(self_: *mut HdyFlap, reveal_flap: gboolean);
    pub fn hdy_flap_set_separator(self_: *mut HdyFlap, separator: *mut gtk::GtkWidget);
    pub fn hdy_flap_set_swipe_to_close(self_: *mut HdyFlap, swipe_to_close: gboolean);
    pub fn hdy_flap_set_swipe_to_open(self_: *mut HdyFlap, swipe_to_open: gboolean);
    pub fn hdy_flap_set_transition_type(
        self_: *mut HdyFlap,
        transition_type: HdyFlapTransitionType,
    );

    //=========================================================================
    // HdyHeaderBar
    //=========================================================================
    pub fn hdy_header_bar_get_type() -> GType;
    pub fn hdy_header_bar_new() -> *mut gtk::GtkWidget;
    pub fn hdy_header_bar_get_centering_policy(self_: *mut HdyHeaderBar) -> HdyCenteringPolicy;
    pub fn hdy_header_bar_get_decoration_layout(self_: *mut HdyHeaderBar) -> *const c_char;
    pub fn hdy_header_bar_get_show_title_buttons(self_: *mut HdyHeaderBar) -> gboolean;
    pub fn hdy_header_bar_get_title_widget(self_: *mut HdyHeaderBar) -> *mut gtk::GtkWidget;
    pub fn hdy_header_bar_pack_end(self_: *mut HdyHeaderBar, child: *mut gtk::GtkWidget);
    pub fn hdy_header_bar_pack_start(self_: *mut HdyHeaderBar, child: *mut gtk::GtkWidget);
    pub fn hdy_header_bar_remove(self_: *mut HdyHeaderBar, child: *mut gtk::GtkWidget);
    pub fn hdy_header_bar_set_centering_policy(
        self_: *mut HdyHeaderBar,
        centering_policy: HdyCenteringPolicy,
    );
    pub fn hdy_header_bar_set_decoration_layout(self_: *mut HdyHeaderBar, layout: *const c_char);
    pub fn hdy_header_bar_set_show_title_buttons(self_: *mut HdyHeaderBar, setting: gboolean);
    pub fn hdy_header_bar_set_title_widget(
        self_: *mut HdyHeaderBar,
        title_widget: *mut gtk::GtkWidget,
    );

    //=========================================================================
    // HdyHeaderGroup
    //=========================================================================
    pub fn hdy_header_group_get_type() -> GType;
    pub fn hdy_header_group_new() -> *mut HdyHeaderGroup;
    pub fn hdy_header_group_add_gtk_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut gtk::GtkHeaderBar,
    );
    pub fn hdy_header_group_add_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut HdyHeaderBar,
    );
    pub fn hdy_header_group_add_header_group(
        self_: *mut HdyHeaderGroup,
        header_group: *mut HdyHeaderGroup,
    );
    pub fn hdy_header_group_get_children(self_: *mut HdyHeaderGroup) -> *mut glib::GSList;
    pub fn hdy_header_group_get_decorate_all(self_: *mut HdyHeaderGroup) -> gboolean;
    pub fn hdy_header_group_remove_child(
        self_: *mut HdyHeaderGroup,
        child: *mut HdyHeaderGroupChild,
    );
    pub fn hdy_header_group_remove_gtk_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut gtk::GtkHeaderBar,
    );
    pub fn hdy_header_group_remove_header_bar(
        self_: *mut HdyHeaderGroup,
        header_bar: *mut HdyHeaderBar,
    );
    pub fn hdy_header_group_remove_header_group(
        self_: *mut HdyHeaderGroup,
        header_group: *mut HdyHeaderGroup,
    );
    pub fn hdy_header_group_set_decorate_all(self_: *mut HdyHeaderGroup, decorate_all: gboolean);

    //=========================================================================
    // HdyHeaderGroupChild
    //=========================================================================
    pub fn hdy_header_group_child_get_type() -> GType;
    pub fn hdy_header_group_child_get_child_type(
        self_: *mut HdyHeaderGroupChild,
    ) -> HdyHeaderGroupChildType;
    pub fn hdy_header_group_child_get_gtk_header_bar(
        self_: *mut HdyHeaderGroupChild,
    ) -> *mut gtk::GtkHeaderBar;
    pub fn hdy_header_group_child_get_header_bar(
        self_: *mut HdyHeaderGroupChild,
    ) -> *mut HdyHeaderBar;
    pub fn hdy_header_group_child_get_header_group(
        self_: *mut HdyHeaderGroupChild,
    ) -> *mut HdyHeaderGroup;

    //=========================================================================
    // HdyKeypad
    //=========================================================================
    pub fn hdy_keypad_get_type() -> GType;
    pub fn hdy_keypad_new(
        symbols_visible: gboolean,
        letters_visible: gboolean,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_keypad_get_column_spacing(self_: *mut HdyKeypad) -> c_uint;
    pub fn hdy_keypad_get_end_action(self_: *mut HdyKeypad) -> *mut gtk::GtkWidget;
    pub fn hdy_keypad_get_entry(self_: *mut HdyKeypad) -> *mut gtk::GtkEntry;
    pub fn hdy_keypad_get_letters_visible(self_: *mut HdyKeypad) -> gboolean;
    pub fn hdy_keypad_get_row_spacing(self_: *mut HdyKeypad) -> c_uint;
    pub fn hdy_keypad_get_start_action(self_: *mut HdyKeypad) -> *mut gtk::GtkWidget;
    pub fn hdy_keypad_get_symbols_visible(self_: *mut HdyKeypad) -> gboolean;
    pub fn hdy_keypad_set_column_spacing(self_: *mut HdyKeypad, spacing: c_uint);
    pub fn hdy_keypad_set_end_action(self_: *mut HdyKeypad, end_action: *mut gtk::GtkWidget);
    pub fn hdy_keypad_set_entry(self_: *mut HdyKeypad, entry: *mut gtk::GtkEntry);
    pub fn hdy_keypad_set_letters_visible(self_: *mut HdyKeypad, letters_visible: gboolean);
    pub fn hdy_keypad_set_row_spacing(self_: *mut HdyKeypad, spacing: c_uint);
    pub fn hdy_keypad_set_start_action(self_: *mut HdyKeypad, start_action: *mut gtk::GtkWidget);
    pub fn hdy_keypad_set_symbols_visible(self_: *mut HdyKeypad, symbols_visible: gboolean);

    //=========================================================================
    // HdyLeaflet
    //=========================================================================
    pub fn hdy_leaflet_get_type() -> GType;
    pub fn hdy_leaflet_new() -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_append(
        self_: *mut HdyLeaflet,
        child: *mut gtk::GtkWidget,
    ) -> *mut HdyLeafletPage;
    pub fn hdy_leaflet_get_adjacent_child(
        self_: *mut HdyLeaflet,
        direction: HdyNavigationDirection,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_get_can_swipe_back(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_can_swipe_forward(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_can_unfold(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_child_by_name(
        self_: *mut HdyLeaflet,
        name: *const c_char,
    ) -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_get_child_transition_duration(self_: *mut HdyLeaflet) -> c_uint;
    pub fn hdy_leaflet_get_child_transition_running(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_folded(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_homogeneous(
        self_: *mut HdyLeaflet,
        folded: gboolean,
        orientation: gtk::GtkOrientation,
    ) -> gboolean;
    pub fn hdy_leaflet_get_interpolate_size(self_: *mut HdyLeaflet) -> gboolean;
    pub fn hdy_leaflet_get_mode_transition_duration(self_: *mut HdyLeaflet) -> c_uint;
    pub fn hdy_leaflet_get_page(
        self_: *mut HdyLeaflet,
        child: *mut gtk::GtkWidget,
    ) -> *mut HdyLeafletPage;
    pub fn hdy_leaflet_get_pages(self_: *mut HdyLeaflet) -> *mut gtk::GtkSelectionModel;
    pub fn hdy_leaflet_get_transition_type(self_: *mut HdyLeaflet) -> HdyLeafletTransitionType;
    pub fn hdy_leaflet_get_visible_child(self_: *mut HdyLeaflet) -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_get_visible_child_name(self_: *mut HdyLeaflet) -> *const c_char;
    pub fn hdy_leaflet_insert_child_after(
        self_: *mut HdyLeaflet,
        child: *mut gtk::GtkWidget,
        sibling: *mut gtk::GtkWidget,
    ) -> *mut HdyLeafletPage;
    pub fn hdy_leaflet_navigate(
        self_: *mut HdyLeaflet,
        direction: HdyNavigationDirection,
    ) -> gboolean;
    pub fn hdy_leaflet_prepend(
        self_: *mut HdyLeaflet,
        child: *mut gtk::GtkWidget,
    ) -> *mut HdyLeafletPage;
    pub fn hdy_leaflet_remove(self_: *mut HdyLeaflet, child: *mut gtk::GtkWidget);
    pub fn hdy_leaflet_reorder_child_after(
        self_: *mut HdyLeaflet,
        child: *mut gtk::GtkWidget,
        sibling: *mut gtk::GtkWidget,
    );
    pub fn hdy_leaflet_set_can_swipe_back(self_: *mut HdyLeaflet, can_swipe_back: gboolean);
    pub fn hdy_leaflet_set_can_swipe_forward(self_: *mut HdyLeaflet, can_swipe_forward: gboolean);
    pub fn hdy_leaflet_set_can_unfold(self_: *mut HdyLeaflet, can_unfold: gboolean);
    pub fn hdy_leaflet_set_child_transition_duration(self_: *mut HdyLeaflet, duration: c_uint);
    pub fn hdy_leaflet_set_homogeneous(
        self_: *mut HdyLeaflet,
        folded: gboolean,
        orientation: gtk::GtkOrientation,
        homogeneous: gboolean,
    );
    pub fn hdy_leaflet_set_interpolate_size(self_: *mut HdyLeaflet, interpolate_size: gboolean);
    pub fn hdy_leaflet_set_mode_transition_duration(self_: *mut HdyLeaflet, duration: c_uint);
    pub fn hdy_leaflet_set_transition_type(
        self_: *mut HdyLeaflet,
        transition: HdyLeafletTransitionType,
    );
    pub fn hdy_leaflet_set_visible_child(
        self_: *mut HdyLeaflet,
        visible_child: *mut gtk::GtkWidget,
    );
    pub fn hdy_leaflet_set_visible_child_name(self_: *mut HdyLeaflet, name: *const c_char);

    //=========================================================================
    // HdyLeafletPage
    //=========================================================================
    pub fn hdy_leaflet_page_get_type() -> GType;
    pub fn hdy_leaflet_page_get_child(self_: *mut HdyLeafletPage) -> *mut gtk::GtkWidget;
    pub fn hdy_leaflet_page_get_name(self_: *mut HdyLeafletPage) -> *const c_char;
    pub fn hdy_leaflet_page_get_navigatable(self_: *mut HdyLeafletPage) -> gboolean;
    pub fn hdy_leaflet_page_set_name(self_: *mut HdyLeafletPage, name: *const c_char);
    pub fn hdy_leaflet_page_set_navigatable(self_: *mut HdyLeafletPage, navigatable: gboolean);

    //=========================================================================
    // HdyPreferencesGroup
    //=========================================================================
    pub fn hdy_preferences_group_get_type() -> GType;
    pub fn hdy_preferences_group_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_group_add(self_: *mut HdyPreferencesGroup, child: *mut gtk::GtkWidget);
    pub fn hdy_preferences_group_get_description(self_: *mut HdyPreferencesGroup) -> *const c_char;
    pub fn hdy_preferences_group_get_title(self_: *mut HdyPreferencesGroup) -> *const c_char;
    pub fn hdy_preferences_group_remove(
        self_: *mut HdyPreferencesGroup,
        child: *mut gtk::GtkWidget,
    );
    pub fn hdy_preferences_group_set_description(
        self_: *mut HdyPreferencesGroup,
        description: *const c_char,
    );
    pub fn hdy_preferences_group_set_title(self_: *mut HdyPreferencesGroup, title: *const c_char);

    //=========================================================================
    // HdyPreferencesPage
    //=========================================================================
    pub fn hdy_preferences_page_get_type() -> GType;
    pub fn hdy_preferences_page_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_page_add(
        self_: *mut HdyPreferencesPage,
        group: *mut HdyPreferencesGroup,
    );
    pub fn hdy_preferences_page_get_icon_name(self_: *mut HdyPreferencesPage) -> *const c_char;
    pub fn hdy_preferences_page_get_title(self_: *mut HdyPreferencesPage) -> *const c_char;
    pub fn hdy_preferences_page_remove(
        self_: *mut HdyPreferencesPage,
        group: *mut HdyPreferencesGroup,
    );
    pub fn hdy_preferences_page_set_icon_name(
        self_: *mut HdyPreferencesPage,
        icon_name: *const c_char,
    );
    pub fn hdy_preferences_page_set_title(self_: *mut HdyPreferencesPage, title: *const c_char);

    //=========================================================================
    // HdyPreferencesRow
    //=========================================================================
    pub fn hdy_preferences_row_get_type() -> GType;
    pub fn hdy_preferences_row_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_row_get_title(self_: *mut HdyPreferencesRow) -> *const c_char;
    pub fn hdy_preferences_row_get_use_underline(self_: *mut HdyPreferencesRow) -> gboolean;
    pub fn hdy_preferences_row_set_title(self_: *mut HdyPreferencesRow, title: *const c_char);
    pub fn hdy_preferences_row_set_use_underline(
        self_: *mut HdyPreferencesRow,
        use_underline: gboolean,
    );

    //=========================================================================
    // HdyPreferencesWindow
    //=========================================================================
    pub fn hdy_preferences_window_get_type() -> GType;
    pub fn hdy_preferences_window_new() -> *mut gtk::GtkWidget;
    pub fn hdy_preferences_window_add(
        self_: *mut HdyPreferencesWindow,
        page: *mut HdyPreferencesPage,
    );
    pub fn hdy_preferences_window_close_subpage(self_: *mut HdyPreferencesWindow);
    pub fn hdy_preferences_window_get_can_swipe_back(self_: *mut HdyPreferencesWindow) -> gboolean;
    pub fn hdy_preferences_window_get_search_enabled(self_: *mut HdyPreferencesWindow) -> gboolean;
    pub fn hdy_preferences_window_present_subpage(
        self_: *mut HdyPreferencesWindow,
        subpage: *mut gtk::GtkWidget,
    );
    pub fn hdy_preferences_window_remove(
        self_: *mut HdyPreferencesWindow,
        page: *mut HdyPreferencesPage,
    );
    pub fn hdy_preferences_window_set_can_swipe_back(
        self_: *mut HdyPreferencesWindow,
        can_swipe_back: gboolean,
    );
    pub fn hdy_preferences_window_set_search_enabled(
        self_: *mut HdyPreferencesWindow,
        search_enabled: gboolean,
    );

    //=========================================================================
    // HdySqueezer
    //=========================================================================
    pub fn hdy_squeezer_get_type() -> GType;
    pub fn hdy_squeezer_new() -> *mut gtk::GtkWidget;
    pub fn hdy_squeezer_add(
        self_: *mut HdySqueezer,
        child: *mut gtk::GtkWidget,
    ) -> *mut HdySqueezerPage;
    pub fn hdy_squeezer_get_homogeneous(self_: *mut HdySqueezer) -> gboolean;
    pub fn hdy_squeezer_get_interpolate_size(self_: *mut HdySqueezer) -> gboolean;
    pub fn hdy_squeezer_get_page(
        self_: *mut HdySqueezer,
        child: *mut gtk::GtkWidget,
    ) -> *mut HdySqueezerPage;
    pub fn hdy_squeezer_get_pages(self_: *mut HdySqueezer) -> *mut gtk::GtkSelectionModel;
    pub fn hdy_squeezer_get_transition_duration(self_: *mut HdySqueezer) -> c_uint;
    pub fn hdy_squeezer_get_transition_running(self_: *mut HdySqueezer) -> gboolean;
    pub fn hdy_squeezer_get_transition_type(self_: *mut HdySqueezer) -> HdySqueezerTransitionType;
    pub fn hdy_squeezer_get_visible_child(self_: *mut HdySqueezer) -> *mut gtk::GtkWidget;
    pub fn hdy_squeezer_get_xalign(self_: *mut HdySqueezer) -> c_float;
    pub fn hdy_squeezer_get_yalign(self_: *mut HdySqueezer) -> c_float;
    pub fn hdy_squeezer_remove(self_: *mut HdySqueezer, child: *mut gtk::GtkWidget);
    pub fn hdy_squeezer_set_homogeneous(self_: *mut HdySqueezer, homogeneous: gboolean);
    pub fn hdy_squeezer_set_interpolate_size(self_: *mut HdySqueezer, interpolate_size: gboolean);
    pub fn hdy_squeezer_set_transition_duration(self_: *mut HdySqueezer, duration: c_uint);
    pub fn hdy_squeezer_set_transition_type(
        self_: *mut HdySqueezer,
        transition: HdySqueezerTransitionType,
    );
    pub fn hdy_squeezer_set_xalign(self_: *mut HdySqueezer, xalign: c_float);
    pub fn hdy_squeezer_set_yalign(self_: *mut HdySqueezer, yalign: c_float);

    //=========================================================================
    // HdySqueezerPage
    //=========================================================================
    pub fn hdy_squeezer_page_get_type() -> GType;
    pub fn hdy_squeezer_page_get_child(self_: *mut HdySqueezerPage) -> *mut gtk::GtkWidget;
    pub fn hdy_squeezer_page_get_enabled(self_: *mut HdySqueezerPage) -> gboolean;
    pub fn hdy_squeezer_page_set_enabled(self_: *mut HdySqueezerPage, enabled: gboolean);

    //=========================================================================
    // HdyStatusPage
    //=========================================================================
    pub fn hdy_status_page_get_type() -> GType;
    pub fn hdy_status_page_new() -> *mut gtk::GtkWidget;
    pub fn hdy_status_page_get_child(self_: *mut HdyStatusPage) -> *mut gtk::GtkWidget;
    pub fn hdy_status_page_get_description(self_: *mut HdyStatusPage) -> *const c_char;
    pub fn hdy_status_page_get_icon_name(self_: *mut HdyStatusPage) -> *const c_char;
    pub fn hdy_status_page_get_title(self_: *mut HdyStatusPage) -> *const c_char;
    pub fn hdy_status_page_set_child(self_: *mut HdyStatusPage, child: *mut gtk::GtkWidget);
    pub fn hdy_status_page_set_description(self_: *mut HdyStatusPage, description: *const c_char);
    pub fn hdy_status_page_set_icon_name(self_: *mut HdyStatusPage, icon_name: *const c_char);
    pub fn hdy_status_page_set_title(self_: *mut HdyStatusPage, title: *const c_char);

    //=========================================================================
    // HdySwipeGroup
    //=========================================================================
    pub fn hdy_swipe_group_get_type() -> GType;
    pub fn hdy_swipe_group_new() -> *mut HdySwipeGroup;
    pub fn hdy_swipe_group_add_swipeable(self_: *mut HdySwipeGroup, swipeable: *mut HdySwipeable);
    pub fn hdy_swipe_group_get_swipeables(self_: *mut HdySwipeGroup) -> *mut glib::GSList;
    pub fn hdy_swipe_group_remove_swipeable(
        self_: *mut HdySwipeGroup,
        swipeable: *mut HdySwipeable,
    );

    //=========================================================================
    // HdySwipeTracker
    //=========================================================================
    pub fn hdy_swipe_tracker_get_type() -> GType;
    pub fn hdy_swipe_tracker_new(swipeable: *mut HdySwipeable) -> *mut HdySwipeTracker;
    pub fn hdy_swipe_tracker_get_allow_mouse_drag(self_: *mut HdySwipeTracker) -> gboolean;
    pub fn hdy_swipe_tracker_get_enabled(self_: *mut HdySwipeTracker) -> gboolean;
    pub fn hdy_swipe_tracker_get_reversed(self_: *mut HdySwipeTracker) -> gboolean;
    pub fn hdy_swipe_tracker_get_swipeable(self_: *mut HdySwipeTracker) -> *mut HdySwipeable;
    pub fn hdy_swipe_tracker_set_allow_mouse_drag(
        self_: *mut HdySwipeTracker,
        allow_mouse_drag: gboolean,
    );
    pub fn hdy_swipe_tracker_set_enabled(self_: *mut HdySwipeTracker, enabled: gboolean);
    pub fn hdy_swipe_tracker_set_reversed(self_: *mut HdySwipeTracker, reversed: gboolean);
    pub fn hdy_swipe_tracker_shift_position(self_: *mut HdySwipeTracker, delta: c_double);

    //=========================================================================
    // HdyValueObject
    //=========================================================================
    pub fn hdy_value_object_get_type() -> GType;
    pub fn hdy_value_object_new(value: *const gobject::GValue) -> *mut HdyValueObject;
    pub fn hdy_value_object_new_collect(type_: GType, ...) -> *mut HdyValueObject;
    pub fn hdy_value_object_new_string(string: *const c_char) -> *mut HdyValueObject;
    pub fn hdy_value_object_new_take_string(string: *mut c_char) -> *mut HdyValueObject;
    pub fn hdy_value_object_copy_value(value: *mut HdyValueObject, dest: *mut gobject::GValue);
    pub fn hdy_value_object_dup_string(value: *mut HdyValueObject) -> *mut c_char;
    pub fn hdy_value_object_get_string(value: *mut HdyValueObject) -> *const c_char;
    pub fn hdy_value_object_get_value(value: *mut HdyValueObject) -> *const gobject::GValue;

    //=========================================================================
    // HdyViewSwitcher
    //=========================================================================
    pub fn hdy_view_switcher_get_type() -> GType;
    pub fn hdy_view_switcher_new() -> *mut gtk::GtkWidget;
    pub fn hdy_view_switcher_get_narrow_ellipsize(
        self_: *mut HdyViewSwitcher,
    ) -> pango::PangoEllipsizeMode;
    pub fn hdy_view_switcher_get_policy(self_: *mut HdyViewSwitcher) -> HdyViewSwitcherPolicy;
    pub fn hdy_view_switcher_get_stack(self_: *mut HdyViewSwitcher) -> *mut gtk::GtkStack;
    pub fn hdy_view_switcher_set_narrow_ellipsize(
        self_: *mut HdyViewSwitcher,
        mode: pango::PangoEllipsizeMode,
    );
    pub fn hdy_view_switcher_set_policy(self_: *mut HdyViewSwitcher, policy: HdyViewSwitcherPolicy);
    pub fn hdy_view_switcher_set_stack(self_: *mut HdyViewSwitcher, stack: *mut gtk::GtkStack);

    //=========================================================================
    // HdyViewSwitcherBar
    //=========================================================================
    pub fn hdy_view_switcher_bar_get_type() -> GType;
    pub fn hdy_view_switcher_bar_new() -> *mut gtk::GtkWidget;
    pub fn hdy_view_switcher_bar_get_policy(
        self_: *mut HdyViewSwitcherBar,
    ) -> HdyViewSwitcherPolicy;
    pub fn hdy_view_switcher_bar_get_reveal(self_: *mut HdyViewSwitcherBar) -> gboolean;
    pub fn hdy_view_switcher_bar_get_stack(self_: *mut HdyViewSwitcherBar) -> *mut gtk::GtkStack;
    pub fn hdy_view_switcher_bar_set_policy(
        self_: *mut HdyViewSwitcherBar,
        policy: HdyViewSwitcherPolicy,
    );
    pub fn hdy_view_switcher_bar_set_reveal(self_: *mut HdyViewSwitcherBar, reveal: gboolean);
    pub fn hdy_view_switcher_bar_set_stack(
        self_: *mut HdyViewSwitcherBar,
        stack: *mut gtk::GtkStack,
    );

    //=========================================================================
    // HdyViewSwitcherTitle
    //=========================================================================
    pub fn hdy_view_switcher_title_get_type() -> GType;
    pub fn hdy_view_switcher_title_new() -> *mut gtk::GtkWidget;
    pub fn hdy_view_switcher_title_get_policy(
        self_: *mut HdyViewSwitcherTitle,
    ) -> HdyViewSwitcherPolicy;
    pub fn hdy_view_switcher_title_get_stack(
        self_: *mut HdyViewSwitcherTitle,
    ) -> *mut gtk::GtkStack;
    pub fn hdy_view_switcher_title_get_subtitle(self_: *mut HdyViewSwitcherTitle) -> *const c_char;
    pub fn hdy_view_switcher_title_get_title(self_: *mut HdyViewSwitcherTitle) -> *const c_char;
    pub fn hdy_view_switcher_title_get_title_visible(self_: *mut HdyViewSwitcherTitle) -> gboolean;
    pub fn hdy_view_switcher_title_get_view_switcher_enabled(
        self_: *mut HdyViewSwitcherTitle,
    ) -> gboolean;
    pub fn hdy_view_switcher_title_set_policy(
        self_: *mut HdyViewSwitcherTitle,
        policy: HdyViewSwitcherPolicy,
    );
    pub fn hdy_view_switcher_title_set_stack(
        self_: *mut HdyViewSwitcherTitle,
        stack: *mut gtk::GtkStack,
    );
    pub fn hdy_view_switcher_title_set_subtitle(
        self_: *mut HdyViewSwitcherTitle,
        subtitle: *const c_char,
    );
    pub fn hdy_view_switcher_title_set_title(
        self_: *mut HdyViewSwitcherTitle,
        title: *const c_char,
    );
    pub fn hdy_view_switcher_title_set_view_switcher_enabled(
        self_: *mut HdyViewSwitcherTitle,
        enabled: gboolean,
    );

    //=========================================================================
    // HdyWindow
    //=========================================================================
    pub fn hdy_window_get_type() -> GType;
    pub fn hdy_window_new() -> *mut gtk::GtkWidget;
    pub fn hdy_window_get_child(self_: *mut HdyWindow) -> *mut gtk::GtkWidget;
    pub fn hdy_window_set_child(self_: *mut HdyWindow, child: *mut gtk::GtkWidget);

    //=========================================================================
    // HdySwipeable
    //=========================================================================
    pub fn hdy_swipeable_get_type() -> GType;
    pub fn hdy_swipeable_emit_child_switched(
        self_: *mut HdySwipeable,
        index: c_uint,
        duration: i64,
    );
    pub fn hdy_swipeable_get_cancel_progress(self_: *mut HdySwipeable) -> c_double;
    pub fn hdy_swipeable_get_distance(self_: *mut HdySwipeable) -> c_double;
    pub fn hdy_swipeable_get_progress(self_: *mut HdySwipeable) -> c_double;
    pub fn hdy_swipeable_get_snap_points(
        self_: *mut HdySwipeable,
        n_snap_points: *mut c_int,
    ) -> *mut c_double;
    pub fn hdy_swipeable_get_swipe_area(
        self_: *mut HdySwipeable,
        navigation_direction: HdyNavigationDirection,
        is_drag: gboolean,
        rect: *mut gdk::GdkRectangle,
    );
    pub fn hdy_swipeable_get_swipe_tracker(self_: *mut HdySwipeable) -> *mut HdySwipeTracker;
    pub fn hdy_swipeable_switch_child(self_: *mut HdySwipeable, index: c_uint, duration: i64);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn hdy_ease_out_cubic(t: c_double) -> c_double;
    pub fn hdy_get_enable_animations(widget: *mut gtk::GtkWidget) -> gboolean;
    pub fn hdy_init();

}
