// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwCenteringPolicy")]
pub enum CenteringPolicy {
    #[doc(alias = "ADW_CENTERING_POLICY_LOOSE")]
    Loose,
    #[doc(alias = "ADW_CENTERING_POLICY_STRICT")]
    Strict,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CenteringPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CenteringPolicy::{}",
            match *self {
                Self::Loose => "Loose",
                Self::Strict => "Strict",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for CenteringPolicy {
    type GlibType = ffi::AdwCenteringPolicy;

    fn into_glib(self) -> ffi::AdwCenteringPolicy {
        match self {
            Self::Loose => ffi::ADW_CENTERING_POLICY_LOOSE,
            Self::Strict => ffi::ADW_CENTERING_POLICY_STRICT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwCenteringPolicy> for CenteringPolicy {
    unsafe fn from_glib(value: ffi::AdwCenteringPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_CENTERING_POLICY_LOOSE => Self::Loose,
            ffi::ADW_CENTERING_POLICY_STRICT => Self::Strict,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CenteringPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_centering_policy_get_type()) }
    }
}

impl glib::value::ValueType for CenteringPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CenteringPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CenteringPolicy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwColorScheme")]
pub enum ColorScheme {
    #[doc(alias = "ADW_COLOR_SCHEME_DEFAULT")]
    Default,
    #[doc(alias = "ADW_COLOR_SCHEME_FORCE_LIGHT")]
    ForceLight,
    #[doc(alias = "ADW_COLOR_SCHEME_PREFER_LIGHT")]
    PreferLight,
    #[doc(alias = "ADW_COLOR_SCHEME_PREFER_DARK")]
    PreferDark,
    #[doc(alias = "ADW_COLOR_SCHEME_FORCE_DARK")]
    ForceDark,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ColorScheme {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ColorScheme::{}",
            match *self {
                Self::Default => "Default",
                Self::ForceLight => "ForceLight",
                Self::PreferLight => "PreferLight",
                Self::PreferDark => "PreferDark",
                Self::ForceDark => "ForceDark",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ColorScheme {
    type GlibType = ffi::AdwColorScheme;

    fn into_glib(self) -> ffi::AdwColorScheme {
        match self {
            Self::Default => ffi::ADW_COLOR_SCHEME_DEFAULT,
            Self::ForceLight => ffi::ADW_COLOR_SCHEME_FORCE_LIGHT,
            Self::PreferLight => ffi::ADW_COLOR_SCHEME_PREFER_LIGHT,
            Self::PreferDark => ffi::ADW_COLOR_SCHEME_PREFER_DARK,
            Self::ForceDark => ffi::ADW_COLOR_SCHEME_FORCE_DARK,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwColorScheme> for ColorScheme {
    unsafe fn from_glib(value: ffi::AdwColorScheme) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_COLOR_SCHEME_DEFAULT => Self::Default,
            ffi::ADW_COLOR_SCHEME_FORCE_LIGHT => Self::ForceLight,
            ffi::ADW_COLOR_SCHEME_PREFER_LIGHT => Self::PreferLight,
            ffi::ADW_COLOR_SCHEME_PREFER_DARK => Self::PreferDark,
            ffi::ADW_COLOR_SCHEME_FORCE_DARK => Self::ForceDark,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ColorScheme {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_color_scheme_get_type()) }
    }
}

impl glib::value::ValueType for ColorScheme {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ColorScheme {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ColorScheme {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwFlapFoldPolicy")]
pub enum FlapFoldPolicy {
    #[doc(alias = "ADW_FLAP_FOLD_POLICY_NEVER")]
    Never,
    #[doc(alias = "ADW_FLAP_FOLD_POLICY_ALWAYS")]
    Always,
    #[doc(alias = "ADW_FLAP_FOLD_POLICY_AUTO")]
    Auto,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FlapFoldPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FlapFoldPolicy::{}",
            match *self {
                Self::Never => "Never",
                Self::Always => "Always",
                Self::Auto => "Auto",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FlapFoldPolicy {
    type GlibType = ffi::AdwFlapFoldPolicy;

    fn into_glib(self) -> ffi::AdwFlapFoldPolicy {
        match self {
            Self::Never => ffi::ADW_FLAP_FOLD_POLICY_NEVER,
            Self::Always => ffi::ADW_FLAP_FOLD_POLICY_ALWAYS,
            Self::Auto => ffi::ADW_FLAP_FOLD_POLICY_AUTO,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwFlapFoldPolicy> for FlapFoldPolicy {
    unsafe fn from_glib(value: ffi::AdwFlapFoldPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_FLAP_FOLD_POLICY_NEVER => Self::Never,
            ffi::ADW_FLAP_FOLD_POLICY_ALWAYS => Self::Always,
            ffi::ADW_FLAP_FOLD_POLICY_AUTO => Self::Auto,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FlapFoldPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_flap_fold_policy_get_type()) }
    }
}

impl glib::value::ValueType for FlapFoldPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FlapFoldPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FlapFoldPolicy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwFlapTransitionType")]
pub enum FlapTransitionType {
    #[doc(alias = "ADW_FLAP_TRANSITION_TYPE_OVER")]
    Over,
    #[doc(alias = "ADW_FLAP_TRANSITION_TYPE_UNDER")]
    Under,
    #[doc(alias = "ADW_FLAP_TRANSITION_TYPE_SLIDE")]
    Slide,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FlapTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FlapTransitionType::{}",
            match *self {
                Self::Over => "Over",
                Self::Under => "Under",
                Self::Slide => "Slide",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FlapTransitionType {
    type GlibType = ffi::AdwFlapTransitionType;

    fn into_glib(self) -> ffi::AdwFlapTransitionType {
        match self {
            Self::Over => ffi::ADW_FLAP_TRANSITION_TYPE_OVER,
            Self::Under => ffi::ADW_FLAP_TRANSITION_TYPE_UNDER,
            Self::Slide => ffi::ADW_FLAP_TRANSITION_TYPE_SLIDE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwFlapTransitionType> for FlapTransitionType {
    unsafe fn from_glib(value: ffi::AdwFlapTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_FLAP_TRANSITION_TYPE_OVER => Self::Over,
            ffi::ADW_FLAP_TRANSITION_TYPE_UNDER => Self::Under,
            ffi::ADW_FLAP_TRANSITION_TYPE_SLIDE => Self::Slide,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FlapTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_flap_transition_type_get_type()) }
    }
}

impl glib::value::ValueType for FlapTransitionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FlapTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FlapTransitionType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwFoldThresholdPolicy")]
pub enum FoldThresholdPolicy {
    #[doc(alias = "ADW_FOLD_THRESHOLD_POLICY_MINIMUM")]
    Minimum,
    #[doc(alias = "ADW_FOLD_THRESHOLD_POLICY_NATURAL")]
    Natural,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FoldThresholdPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "FoldThresholdPolicy::{}",
            match *self {
                Self::Minimum => "Minimum",
                Self::Natural => "Natural",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for FoldThresholdPolicy {
    type GlibType = ffi::AdwFoldThresholdPolicy;

    fn into_glib(self) -> ffi::AdwFoldThresholdPolicy {
        match self {
            Self::Minimum => ffi::ADW_FOLD_THRESHOLD_POLICY_MINIMUM,
            Self::Natural => ffi::ADW_FOLD_THRESHOLD_POLICY_NATURAL,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwFoldThresholdPolicy> for FoldThresholdPolicy {
    unsafe fn from_glib(value: ffi::AdwFoldThresholdPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_FOLD_THRESHOLD_POLICY_MINIMUM => Self::Minimum,
            ffi::ADW_FOLD_THRESHOLD_POLICY_NATURAL => Self::Natural,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for FoldThresholdPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_fold_threshold_policy_get_type()) }
    }
}

impl glib::value::ValueType for FoldThresholdPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FoldThresholdPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FoldThresholdPolicy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwLeafletTransitionType")]
pub enum LeafletTransitionType {
    #[doc(alias = "ADW_LEAFLET_TRANSITION_TYPE_OVER")]
    Over,
    #[doc(alias = "ADW_LEAFLET_TRANSITION_TYPE_UNDER")]
    Under,
    #[doc(alias = "ADW_LEAFLET_TRANSITION_TYPE_SLIDE")]
    Slide,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LeafletTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "LeafletTransitionType::{}",
            match *self {
                Self::Over => "Over",
                Self::Under => "Under",
                Self::Slide => "Slide",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for LeafletTransitionType {
    type GlibType = ffi::AdwLeafletTransitionType;

    fn into_glib(self) -> ffi::AdwLeafletTransitionType {
        match self {
            Self::Over => ffi::ADW_LEAFLET_TRANSITION_TYPE_OVER,
            Self::Under => ffi::ADW_LEAFLET_TRANSITION_TYPE_UNDER,
            Self::Slide => ffi::ADW_LEAFLET_TRANSITION_TYPE_SLIDE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwLeafletTransitionType> for LeafletTransitionType {
    unsafe fn from_glib(value: ffi::AdwLeafletTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_LEAFLET_TRANSITION_TYPE_OVER => Self::Over,
            ffi::ADW_LEAFLET_TRANSITION_TYPE_UNDER => Self::Under,
            ffi::ADW_LEAFLET_TRANSITION_TYPE_SLIDE => Self::Slide,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for LeafletTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_leaflet_transition_type_get_type()) }
    }
}

impl glib::value::ValueType for LeafletTransitionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for LeafletTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LeafletTransitionType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwNavigationDirection")]
pub enum NavigationDirection {
    #[doc(alias = "ADW_NAVIGATION_DIRECTION_BACK")]
    Back,
    #[doc(alias = "ADW_NAVIGATION_DIRECTION_FORWARD")]
    Forward,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NavigationDirection {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "NavigationDirection::{}",
            match *self {
                Self::Back => "Back",
                Self::Forward => "Forward",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for NavigationDirection {
    type GlibType = ffi::AdwNavigationDirection;

    fn into_glib(self) -> ffi::AdwNavigationDirection {
        match self {
            Self::Back => ffi::ADW_NAVIGATION_DIRECTION_BACK,
            Self::Forward => ffi::ADW_NAVIGATION_DIRECTION_FORWARD,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwNavigationDirection> for NavigationDirection {
    unsafe fn from_glib(value: ffi::AdwNavigationDirection) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_NAVIGATION_DIRECTION_BACK => Self::Back,
            ffi::ADW_NAVIGATION_DIRECTION_FORWARD => Self::Forward,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for NavigationDirection {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_navigation_direction_get_type()) }
    }
}

impl glib::value::ValueType for NavigationDirection {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for NavigationDirection {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NavigationDirection {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwSqueezerTransitionType")]
pub enum SqueezerTransitionType {
    #[doc(alias = "ADW_SQUEEZER_TRANSITION_TYPE_NONE")]
    None,
    #[doc(alias = "ADW_SQUEEZER_TRANSITION_TYPE_CROSSFADE")]
    Crossfade,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SqueezerTransitionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SqueezerTransitionType::{}",
            match *self {
                Self::None => "None",
                Self::Crossfade => "Crossfade",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for SqueezerTransitionType {
    type GlibType = ffi::AdwSqueezerTransitionType;

    fn into_glib(self) -> ffi::AdwSqueezerTransitionType {
        match self {
            Self::None => ffi::ADW_SQUEEZER_TRANSITION_TYPE_NONE,
            Self::Crossfade => ffi::ADW_SQUEEZER_TRANSITION_TYPE_CROSSFADE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwSqueezerTransitionType> for SqueezerTransitionType {
    unsafe fn from_glib(value: ffi::AdwSqueezerTransitionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_SQUEEZER_TRANSITION_TYPE_NONE => Self::None,
            ffi::ADW_SQUEEZER_TRANSITION_TYPE_CROSSFADE => Self::Crossfade,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for SqueezerTransitionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_squeezer_transition_type_get_type()) }
    }
}

impl glib::value::ValueType for SqueezerTransitionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SqueezerTransitionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SqueezerTransitionType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "AdwViewSwitcherPolicy")]
pub enum ViewSwitcherPolicy {
    #[doc(alias = "ADW_VIEW_SWITCHER_POLICY_NARROW")]
    Narrow,
    #[doc(alias = "ADW_VIEW_SWITCHER_POLICY_WIDE")]
    Wide,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ViewSwitcherPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "ViewSwitcherPolicy::{}",
            match *self {
                Self::Narrow => "Narrow",
                Self::Wide => "Wide",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for ViewSwitcherPolicy {
    type GlibType = ffi::AdwViewSwitcherPolicy;

    fn into_glib(self) -> ffi::AdwViewSwitcherPolicy {
        match self {
            Self::Narrow => ffi::ADW_VIEW_SWITCHER_POLICY_NARROW,
            Self::Wide => ffi::ADW_VIEW_SWITCHER_POLICY_WIDE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::AdwViewSwitcherPolicy> for ViewSwitcherPolicy {
    unsafe fn from_glib(value: ffi::AdwViewSwitcherPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::ADW_VIEW_SWITCHER_POLICY_NARROW => Self::Narrow,
            ffi::ADW_VIEW_SWITCHER_POLICY_WIDE => Self::Wide,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for ViewSwitcherPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::adw_view_switcher_policy_get_type()) }
    }
}

impl glib::value::ValueType for ViewSwitcherPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ViewSwitcherPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ViewSwitcherPolicy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
